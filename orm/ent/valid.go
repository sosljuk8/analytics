// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"entgo.io/ent"
	"github.com/go-playground/validator"
	"github.com/sosljuk8/analytics/orm/ent/hook"
)

var Validate = validator.New()

// Validate Message with struct literals
func (n *Message) Validate() error {
	return Validate.Struct(n)
}

// Validate MessageMutation with Message struct literals
func (m *MessageMutation) Validate() error {
	obj := &Message{}

	if v, ok := m.Direction(); ok {
		obj.Direction = v
	}

	if v, ok := m.Sent(); ok {
		obj.Sent = v
	}

	if v, ok := m.MailboxId(); ok {
		obj.MailboxId = v
	}

	if v, ok := m.CrmRid(); ok {
		obj.CrmRid = v
	}

	return Validate.Struct(obj)
}

// MessageValidationHook returns ent hook that validates the mutation before it is applied.
// Use it on new ent client creation:
// client := ent.NewClient(ent.Debug(), ent.Hooks(MessageValidationHook()))
func MessageValidationHook() ent.Hook {
	h := func(next ent.Mutator) ent.Mutator {
		return hook.MessageFunc(func(ctx context.Context, m *MessageMutation) (ent.Value, error) {
			if err := m.Validate(); err != nil {
				return nil, err
			}
			return next.Mutate(ctx, m)
		})
	}
	// Limit the hook only for these operations.
	return hook.On(h, ent.OpCreate|ent.OpUpdate|ent.OpUpdateOne)
}

// Validation with struct literals based on ent hooks.
func Validation() Option {
	return func(c *config) {
		c.hooks.Message = append(c.hooks.Message, MessageValidationHook())
	}
}
